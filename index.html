<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Shuffler MVP</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
    }

    .app {
      max-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      background: #1b1b1b;
      padding: 10px 12px;
      border-radius: 8px;
    }

    .controls label {
      font-size: 0.9rem;
      opacity: 0.9;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    select, button {
      background: #222;
      color: #f5f5f5;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:hover {
      background: #333;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .canvases {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      align-items: flex-start;
    }

    .canvas-wrapper {
      background: #1b1b1b;
      border-radius: 8px;
      padding: 10px;
    }

    .canvas-wrapper h2 {
      font-size: 0.95rem;
      margin: 0 0 8px 0;
      opacity: 0.85;
    }

    canvas {
      max-width: 100%;
      border-radius: 4px;
      background: #000;
    }

    .status {
      font-size: 0.9rem;
      opacity: 0.8;
      min-height: 1.2em;
    }

    .footer {
      font-size: 0.8rem;
      opacity: 0.6;
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: baseline;
      justify-content: space-between;
      width: 100%;
      max-width: 1000px;
    }

    .version {
      font-size: 0.8rem;
      opacity: 0.7;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>Pixel Shuffler</h1>

    <div class="controls">
      <label>
        Image:
        <input type="file" id="fileInput" accept="image/*" />
      </label>

      <label>
        Mode:
        <select id="modeSelect">
          <option value="random">Random Shuffle</option>
          <option value="brightness">Sort by Brightness</option>
          <option value="hue">Sort by Hue</option>
          <option value="hueSand">Hue Sand (Gravity)</option> <!-- updated name -->
        </select>
      </label>

      <button id="applyBtn" disabled>Apply</button>
      <button id="downloadBtn" disabled>Download Result</button>

      <span class="status" id="statusText"></span>
    </div>

    <div class="canvases">
      <div class="canvas-wrapper">
        <h2>Original</h2>
        <canvas id="originalCanvas"></canvas>
      </div>
      <div class="canvas-wrapper">
        <h2>Transformed</h2>
        <canvas id="outputCanvas"></canvas>
      </div>
    </div>
  </div>

  <div class="footer">
    <span>Upload an image, pick a mode, then click "Apply".</span>
    <span class="version">Version: <span id="versionText"></span></span>
  </div>

  <script>
    // ---- Version ---------------------------------------------------------
    const APP_VERSION = '0.4.0';
    document.getElementById('versionText').textContent = APP_VERSION;

    // ---- DOM elements ----------------------------------------------------
    const fileInput = document.getElementById('fileInput');
    const modeSelect = document.getElementById('modeSelect');
    const applyBtn = document.getElementById('applyBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const statusText = document.getElementById('statusText');

    const originalCanvas = document.getElementById('originalCanvas');
    const outputCanvas = document.getElementById('outputCanvas');
    const originalCtx = originalCanvas.getContext('2d');
    const outputCtx = outputCanvas.getContext('2d');

    let imageLoaded = false;

    // ---- Helpers ---------------------------------------------------------

    function setStatus(msg) {
      statusText.textContent = msg || '';
    }

    function shuffleArray(array) {
      // Fisher-Yates shuffle
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
    }

    function getBrightness(r, g, b) {
      // Standard luma formula
      return 0.299 * r + 0.587 * g + 0.114 * b;
    }

    // RGB -> HSV helper (h: 0–360, s: 0–1, v: 0–1)
    function rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const d = max - min;

      let h = 0;
      const v = max;
      const s = max === 0 ? 0 : d / max;

      if (d !== 0) {
        if (max === r) {
          h = ((g - b) / d) % 6;
        } else if (max === g) {
          h = (b - r) / d + 2;
        } else {
          h = (r - g) / d + 4;
        }
        h *= 60;
        if (h < 0) h += 360;
      }

      return { h, s, v };
    }

    // ---- Image loading ---------------------------------------------------

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();

      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          // Optional: resize large images down
          const maxSide = 1200;
          let { width, height } = img;

          if (width > maxSide || height > maxSide) {
            const scale = Math.min(maxSide / width, maxSide / height);
            width = Math.round(width * scale);
            height = Math.round(height * scale);
          }

          originalCanvas.width = width;
          originalCanvas.height = height;
          outputCanvas.width = width;
          outputCanvas.height = height;

          originalCtx.clearRect(0, 0, width, height);
          outputCtx.clearRect(0, 0, width, height);

          originalCtx.drawImage(img, 0, 0, width, height);
          setStatus('Image loaded. Choose a mode and click Apply.');
          imageLoaded = true;
          applyBtn.disabled = false;
          downloadBtn.disabled = true;
        };
        img.src = e.target.result;
      };

      reader.onerror = () => {
        setStatus('Error loading image. Please try another file.');
      };

      reader.readAsDataURL(file);
      setStatus('Reading image...');
    });

    // ---- Pixel transforms ------------------------------------------------

    function transformRandomShuffle(imageData) {
      const { data, width, height } = imageData;
      const numPixels = width * height;

      const indices = new Uint32Array(numPixels);
      for (let i = 0; i < numPixels; i++) {
        indices[i] = i;
      }

      shuffleArray(indices);

      const newData = new Uint8ClampedArray(data.length);

      for (let i = 0; i < numPixels; i++) {
        const srcIndex = indices[i];
        const dstOffset = i * 4;
        const srcOffset = srcIndex * 4;

        newData[dstOffset] = data[srcOffset];       // R
        newData[dstOffset + 1] = data[srcOffset+1]; // G
        newData[dstOffset + 2] = data[srcOffset+2]; // B
        newData[dstOffset + 3] = data[srcOffset+3]; // A
      }

      return new ImageData(newData, width, height);
    }

    function transformSortByBrightness(imageData) {
      const { data, width, height } = imageData;
      const numPixels = width * height;

      const pixels = new Array(numPixels);

      for (let i = 0; i < numPixels; i++) {
        const offset = i * 4;
        const r = data[offset];
        const g = data[offset + 1];
        const b = data[offset + 2];
        const a = data[offset + 3];

        pixels[i] = {
          r, g, b, a,
          brightness: getBrightness(r, g, b)
        };
      }

      pixels.sort((p1, p2) => p1.brightness - p2.brightness);

      const newData = new Uint8ClampedArray(data.length);
      for (let i = 0; i < numPixels; i++) {
        const { r, g, b, a } = pixels[i];
        const offset = i * 4;
        newData[offset] = r;
        newData[offset + 1] = g;
        newData[offset + 2] = b;
        newData[offset + 3] = a;
      }

      return new ImageData(newData, width, height);
    }

    function transformSortByHue(imageData) {
      const { data, width, height } = imageData;
      const numPixels = width * height;

      const pixels = new Array(numPixels);

      for (let i = 0; i < numPixels; i++) {
        const offset = i * 4;
        const r = data[offset];
        const g = data[offset + 1];
        const b = data[offset + 2];
        const a = data[offset + 3];

        const { h, s, v } = rgbToHsv(r, g, b);

        pixels[i] = {
          r, g, b, a,
          h, s, v
        };
      }

      // Sort by hue, then by saturation, then value
      pixels.sort((p1, p2) => {
        if (p1.h !== p2.h) return p1.h - p2.h;
        if (p1.s !== p2.s) return p1.s - p2.s;
        return p1.v - p2.v;
      });

      const newData = new Uint8ClampedArray(data.length);
      for (let i = 0; i < numPixels; i++) {
        const { r, g, b, a } = pixels[i];
        const offset = i * 4;
        newData[offset] = r;
        newData[offset + 1] = g;
        newData[offset + 2] = b;
        newData[offset + 3] = a;
      }

      return new ImageData(newData, width, height);
    }

    // NEW: Hue Sand (Gravity)
    function transformHueSand(imageData) {
      const { data, width, height } = imageData;
      const numPixels = width * height;

      const numBuckets = 12; // number of hue bands
      const buckets = Array.from({ length: numBuckets }, () => []);

      // 1) Bucket pixels by hue
      for (let i = 0; i < numPixels; i++) {
        const offset = i * 4;
        const r = data[offset];
        const g = data[offset + 1];
        const b = data[offset + 2];
        const a = data[offset + 3];

        const { h } = rgbToHsv(r, g, b);
        let bucketIndex = Math.floor((h / 360) * numBuckets);
        if (isNaN(bucketIndex) || bucketIndex < 0) bucketIndex = 0;
        if (bucketIndex >= numBuckets) bucketIndex = numBuckets - 1;

        buckets[bucketIndex].push([r, g, b, a]);
      }

      // 2) Shuffle inside each bucket so layers look more "grainy"
      for (let b = 0; b < numBuckets; b++) {
        shuffleArray(buckets[b]);
      }

      // 3) Gravity-based stacking:
      //    We have a "height" per column (how many pixels already stacked from bottom).
      const heights = new Array(width).fill(0);
      const newData = new Uint8ClampedArray(data.length);

      // Fill newData with transparent black just in case
      for (let i = 0; i < newData.length; i += 4) {
        newData[i] = 0;
        newData[i + 1] = 0;
        newData[i + 2] = 0;
        newData[i + 3] = 255;
      }

      // Helper to find a column that still has space
      function findColumnWithSpace(startX) {
        let x = startX;
        // Try random columns a few times
        for (let i = 0; i < 10; i++) {
          x = Math.floor(Math.random() * width);
          if (heights[x] < height) return x;
        }
        // Fallback: linear scan
        for (let col = 0; col < width; col++) {
          if (heights[col] < height) return col;
        }
        return null; // full (should not really happen until we place all pixels)
      }

      // We process buckets in hue order so lower hues become lower layers.
      for (let b = 0; b < numBuckets; b++) {
        const bucket = buckets[b];
        for (let i = 0; i < bucket.length; i++) {
          let x = Math.floor(Math.random() * width);
          x = findColumnWithSpace(x);
          if (x === null) {
            // No space left (safety guard).
            continue;
          }
          const columnHeight = heights[x]; // how many pixels already stacked

          if (columnHeight >= height) {
            continue;
          }

          // bottom row has index height - 1
          const destY = (height - 1) - columnHeight;
          const offset = (destY * width + x) * 4;

          const [r, g, bCh, a] = bucket[i];
          newData[offset] = r;
          newData[offset + 1] = g;
          newData[offset + 2] = bCh;
          newData[offset + 3] = a;

          heights[x] = columnHeight + 1;
        }
      }

      return new ImageData(newData, width, height);
    }

    // ---- Apply button ----------------------------------------------------

    applyBtn.addEventListener('click', () => {
      if (!imageLoaded) {
        alert('Please load an image first.');
        return;
      }

      const mode = modeSelect.value;

      const width = originalCanvas.width;
      const height = originalCanvas.height;

      const imageData = originalCtx.getImageData(0, 0, width, height);

      setStatus('Processing...');
      applyBtn.disabled = true;
      downloadBtn.disabled = true;

      // Give the browser a tick to update UI before heavy work
      setTimeout(() => {
        let result;

        try {
          if (mode === 'random') {
            result = transformRandomShuffle(imageData);
          } else if (mode === 'brightness') {
            result = transformSortByBrightness(imageData);
          } else if (mode === 'hue') {
            result = transformSortByHue(imageData);
          } else if (mode === 'hueSand') {
            result = transformHueSand(imageData);
          } else {
            setStatus('Unknown mode.');
            applyBtn.disabled = false;
            return;
          }

          outputCtx.putImageData(result, 0, 0);
          setStatus('Done. You can download the result.');
          downloadBtn.disabled = false;
        } catch (err) {
          console.error(err);
          setStatus('Error during processing.');
        } finally {
          applyBtn.disabled = false;
        }
      }, 30);
    });

    // ---- Download button -------------------------------------------------

    downloadBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'pixel-shuffled.png';
      link.href = outputCanvas.toDataURL('image/png');
      link.click();
    });
  </script>
</body>
</html>
