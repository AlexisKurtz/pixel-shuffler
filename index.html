<!--
Pixel Shuffler - Sand Layers
Version: 0.8.0

Changelog:
- 0.8.0
  - Switched from falling-sand particle simulation to a contour-based "sand mound"
    renderer:
      * Mounds are generated as smooth bell-shaped curves (heightfield).
      * Colors come from the input image: pixels are converted to HSV and sorted
        by brightness (V), then hue (H), then saturation (S) to form a gradient.
      * Each mound is sliced into horizontal bands; band index is mapped to the
        gradient to create smooth layered sand, similar to stylized sand-art hills.
- 0.7.2
  - Added horizontal jitter selector for falling-sand physics (now removed).
- 0.7.1
  - Dark-to-light sorting using HSV (V -> H -> S) for sand particle drop order.
- 0.7.0
  - Initial Sand Layers mode with falling-sand behavior and global HSV ordering.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Shuffler MVP</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #f2e4c9; /* warm paper background like sand art */
      color: #222;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .version-inline {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .app {
      max-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      background: #f7f0dc;
      padding: 10px 12px;
      border-radius: 8px;
      border: 1px solid #e0d4b8;
    }

    .controls label {
      font-size: 0.9rem;
      opacity: 0.9;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    select, button {
      background: #fffaf0;
      color: #222;
      border: 1px solid #c9bca0;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:hover {
      background: #f0e4c5;
    }

    button:disabled {
      opacity: 0.4;
      cursor: default;
    }

    .canvases {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      align-items: flex-start;
    }

    .canvas-wrapper {
      background: #f7f0dc;
      border-radius: 8px;
      padding: 10px;
      border: 1px solid #e0d4b8;
    }

    .canvas-wrapper h2 {
      font-size: 0.95rem;
      margin: 0 0 8px 0;
      opacity: 0.85;
    }

    canvas {
      max-width: 100%;
      border-radius: 4px;
      background: transparent;
      display: block;
    }

    .status {
      font-size: 0.9rem;
      opacity: 0.8;
      min-height: 1.2em;
    }

    .footer {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: baseline;
      justify-content: space-between;
      width: 100%;
      max-width: 1000px;
      color: #444;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>
      Pixel Shuffler
      <span class="version-inline js-version-inline"></span>
    </h1>

    <div class="controls">
      <label>
        Image:
        <input type="file" id="fileInput" accept="image/*" />
      </label>

      <label>
        Mounds:
        <select id="moundsSelect">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
        </select>
      </label>

      <label>
        Bands:
        <select id="bandsSelect">
          <option value="20">20</option>
          <option value="30" selected>30</option>
          <option value="40">40</option>
          <option value="60">60</option>
        </select>
      </label>

      <button id="applyBtn" disabled>Apply Sand Layers</button>
      <button id="downloadBtn" disabled>Download Result</button>

      <span class="status" id="statusText"></span>
    </div>

    <div class="canvases">
      <div class="canvas-wrapper">
        <h2>Original</h2>
        <canvas id="originalCanvas"></canvas>
      </div>
      <div class="canvas-wrapper">
        <h2>Sand Layers Output</h2>
        <canvas id="outputCanvas"></canvas>
      </div>
    </div>
  </div>

  <div class="footer">
    <span>Upload an image, choose mound count & bands, then click "Apply Sand Layers".</span>
    <span>Version: <span class="js-version-footer"></span></span>
  </div>

  <script>
    // ---- Version ---------------------------------------------------------
    const APP_VERSION = '0.8.0';
    document.querySelector('.js-version-inline').textContent = `· v${APP_VERSION}`;
    document.querySelector('.js-version-footer').textContent = APP_VERSION;

    // ---- DOM elements ----------------------------------------------------
    const fileInput     = document.getElementById('fileInput');
    const moundsSelect  = document.getElementById('moundsSelect');
    const bandsSelect   = document.getElementById('bandsSelect');
    const applyBtn      = document.getElementById('applyBtn');
    const downloadBtn   = document.getElementById('downloadBtn');
    const statusText    = document.getElementById('statusText');

    const originalCanvas = document.getElementById('originalCanvas');
    const outputCanvas   = document.getElementById('outputCanvas');
    const originalCtx    = originalCanvas.getContext('2d');
    const outputCtx      = outputCanvas.getContext('2d');

    let imageLoaded = false;
    let lastImageData = null;

    // ---- Helpers ---------------------------------------------------------

    function setStatus(msg) {
      statusText.textContent = msg || '';
    }

    // RGB -> HSV helper (h: 0–360, s: 0–1, v: 0–1)
    function rgbToHsv(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;

      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const d   = max - min;

      let h = 0;
      const v = max;
      const s = max === 0 ? 0 : d / max;

      if (d !== 0) {
        if (max === r) {
          h = ((g - b) / d) % 6;
        } else if (max === g) {
          h = (b - r) / d + 2;
        } else {
          h = (r - g) / d + 4;
        }
        h *= 60;
        if (h < 0) h += 360;
      }

      return { h, s, v };
    }

    // Build a gradient (array of colors) from the image's pixels
    function buildGradientFromImage(imageData, numBands) {
      const { data, width, height } = imageData;
      const numPixels = width * height;
      const pixels = [];

      for (let i = 0; i < numPixels; i++) {
        const offset = i * 4;
        const r = data[offset];
        const g = data[offset + 1];
        const b = data[offset + 2];
        const a = data[offset + 3];

        const { h, s, v } = rgbToHsv(r, g, b);
        pixels.push({ r, g, b, a, h, s, v });
      }

      // Sort mainly by brightness (dark -> light), then by hue, then saturation
      pixels.sort((p1, p2) => {
        if (p1.v !== p2.v) return p1.v - p2.v;
        if (p1.h !== p2.h) return p1.h - p2.h;
        return p1.s - p2.s;
      });

      const gradient = [];
      if (pixels.length === 0) {
        // fallback: grayscale gradient
        for (let i = 0; i < numBands; i++) {
          const v = Math.round((i / (numBands - 1)) * 255);
          gradient.push({ r: v, g: v, b: v, a: 255 });
        }
        return gradient;
      }

      // Sample evenly along the sorted list
      for (let i = 0; i < numBands; i++) {
        const t = i / (numBands - 1);
        const index = Math.floor(t * (pixels.length - 1));
        const p = pixels[index];
        gradient.push({ r: p.r, g: p.g, b: p.b, a: 255 });
      }

      return gradient;
    }

    // Generate mounds as a heightfield (smooth hills)
    function generateMoundHeights(width, height, moundCount) {
      const m = Math.max(1, Math.min(6, moundCount));
      const centers = [];
      const amplitudes = [];
      const sigmas = [];

      // Spread centers evenly
      for (let i = 0; i < m; i++) {
        const centerX = (i + 0.5) * (width / m);
        centers.push(centerX);
      }

      // Heights & widths of mounds
      const maxAmplitude = height * 0.6; // max mound height
      for (let i = 0; i < m; i++) {
        // small random variation so mounds aren't identical
        const amp = maxAmplitude * (0.8 + Math.random() * 0.4);
        amplitudes.push(amp);
        const sigma = width / (m * 2.2);
        sigmas.push(sigma);
      }

      const heights = new Float32Array(width);

      for (let x = 0; x < width; x++) {
        let h = 0;
        for (let i = 0; i < m; i++) {
          const dx = x - centers[i];
          const s = sigmas[i];
          const gauss = amplitudes[i] * Math.exp(-0.5 * (dx * dx) / (s * s));
          if (gauss > h) h = gauss; // use max for nice overlapping peaks
        }
        heights[x] = h;
      }

      return heights;
    }

    // Main render: contour-based sand layers
    function renderSandLayers(imageData, moundCount, numBands) {
      const width = outputCanvas.width;
      const height = outputCanvas.height;

      // 1) Build gradient from the original image
      const gradient = buildGradientFromImage(imageData, numBands);

      // 2) Build mounds heightfield
      const moundHeights = generateMoundHeights(width, height, moundCount);

      // 3) Draw sand layers
      const outData = outputCtx.createImageData(width, height);
      const data = outData.data;

      // Background: same tone as page
      const bgR = 242, bgG = 228, bgB = 201;

      for (let y = 0; y < height; y++) {
        const yFromBottom = height - 1 - y;

        for (let x = 0; x < width; x++) {
          const idx = (y * width + x) * 4;
          const moundHeight = moundHeights[x];

          if (yFromBottom <= 0 || moundHeight <= 0 || yFromBottom > moundHeight) {
            // outside mound -> background
            data[idx]     = bgR;
            data[idx + 1] = bgG;
            data[idx + 2] = bgB;
            data[idx + 3] = 255;
          } else {
            // inside mound -> choose band based on normalized height
            const t = yFromBottom / moundHeight; // 0 bottom, 1 top
            const bandIndex = Math.max(
              0,
              Math.min(numBands - 1, Math.floor(t * (numBands - 1)))
            );
            const c = gradient[bandIndex];

            data[idx]     = c.r;
            data[idx + 1] = c.g;
            data[idx + 2] = c.b;
            data[idx + 3] = 255;
          }
        }
      }

      outputCtx.putImageData(outData, 0, 0);
    }

    // ---- Image loading ---------------------------------------------------

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;

      const reader = new FileReader();

      reader.onload = (e) => {
        const img = new Image();
        img.onload = () => {
          // Resize large images down for performance
          const maxSide = 800;
          let { width, height } = img;

          if (width > maxSide || height > maxSide) {
            const scale = Math.min(maxSide / width, maxSide / height);
            width = Math.round(width * scale);
            height = Math.round(height * scale);
          }

          originalCanvas.width  = width;
          originalCanvas.height = height;
          outputCanvas.width    = width;
          outputCanvas.height   = height;

          originalCtx.clearRect(0, 0, width, height);
          outputCtx.clearRect(0, 0, width, height);

          originalCtx.drawImage(img, 0, 0, width, height);

          // store image data for gradient building
          lastImageData = originalCtx.getImageData(0, 0, width, height);

          setStatus('Image loaded. Choose mound count & bands, then click "Apply Sand Layers".');
          imageLoaded = true;
          applyBtn.disabled = false;
          downloadBtn.disabled = true;
        };
        img.src = e.target.result;
      };

      reader.onerror = () => {
        setStatus('Error loading image. Please try another file.');
      };

      reader.readAsDataURL(file);
      setStatus('Reading image...');
    });

    // ---- Apply button ----------------------------------------------------

    applyBtn.addEventListener('click', () => {
      if (!imageLoaded || !lastImageData) {
        alert('Please load an image first.');
        return;
      }

      const moundCount = parseInt(moundsSelect.value, 10) || 2;
      const numBands   = parseInt(bandsSelect.value, 10) || 30;

      setStatus('Rendering Sand Layers...');
      applyBtn.disabled = true;
      downloadBtn.disabled = true;

      setTimeout(() => {
        try {
          renderSandLayers(lastImageData, moundCount, numBands);
          setStatus('Done. You can download the result.');
          downloadBtn.disabled = false;
        } catch (err) {
          console.error(err);
          setStatus('Error during processing.');
        } finally {
          applyBtn.disabled = false;
        }
      }, 30);
    });

    // ---- Download button -------------------------------------------------

    downloadBtn.addEventListener('click', () => {
      const link = document.createElement('a');
      link.download = 'pixel-sand-layers.png';
      link.href = outputCanvas.toDataURL('image/png');
      link.click();
    });
  </script>
</body>
</html>
