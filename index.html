<!--
Pixel Shuffler - Sand Layers + Vertical/Horizontal Shift
Version: 0.11.0

Changelog:
- 0.11.0
  - Added "Horizontal Shift" mode:
      * Operates on rows instead of columns.
      * Rows are grouped in vertical blocks of size X pixels (user-defined).
      * For each block:
          - First block: shift its rows LEFT by X pixels (with horizontal wrap).
          - Next block: shift its rows RIGHT by X pixels.
          - Alternating left/right down the image.
      * Pure pixel rearrangement, no creation/removal.
  - Persist last loaded image using localStorage:
      * The last image (as a data URL) is stored on load.
      * On page refresh/reopen, the app restores and redraws that image
        automatically (if still available in localStorage).
- 0.10.2
  - Wrapped JS in window.onload, fixed Apply wiring robustness.
- 0.10.0–0.10.1
  - Added Vertical Shift mode and basic mode switching.
- 0.9.x
  - Sand Layout mode with brightness-based mound layout (true pixel shuffling).
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Shuffler MVP</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .version-inline {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .app {
      max-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      background: #1b1b1b;
      padding: 10px 12px;
      border-radius: 8px;
    }

    .controls label {
      font-size: 0.9rem;
      opacity: 0.9;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    select, button, input[type="number"] {
      background: #222;
      color: #f5f5f5;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:hover {
      background: #333;
    }

    input[type="number"] {
      width: 70px;
    }

    .canvases {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      align-items: flex-start;
    }

    .canvas-wrapper {
      background: #1b1b1b;
      border-radius: 8px;
      padding: 10px;
    }

    .canvas-wrapper h2 {
      font-size: 0.95rem;
      margin: 0 0 8px 0;
      opacity: 0.85;
    }

    canvas {
      max-width: 100%;
      border-radius: 4px;
      background: #000;
      display: block;
    }

    .status {
      font-size: 0.9rem;
      opacity: 0.8;
      min-height: 1.2em;
    }

    .footer {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: baseline;
      justify-content: space-between;
      width: 100%;
      max-width: 1000px;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>
      Pixel Shuffler
      <span class="version-inline js-version-inline"></span>
    </h1>

    <div class="controls">
      <label>
        Image:
        <input type="file" id="fileInput" accept="image/*" />
      </label>

      <label>
        Mode:
        <select id="modeSelect">
          <option value="sand">Sand Layout</option>
          <option value="verticalShift">Vertical Shift</option>
          <option value="horizontalShift">Horizontal Shift</option>
        </select>
      </label>

      <label id="moundsLabel">
        Mounds:
        <select id="moundsSelect">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
        </select>
      </label>

      <label id="shiftLabel" style="display:none;">
        Shift size (px):
        <input type="number" id="shiftSizeInput" min="1" max="500" value="20" />
      </label>

      <button id="applyBtn">Apply</button>
      <button id="downloadBtn" disabled>Download Result</button>

      <span class="status" id="statusText"></span>
    </div>

    <div class="canvases">
      <div class="canvas-wrapper">
        <h2>Original</h2>
        <canvas id="originalCanvas"></canvas>
      </div>
      <div class="canvas-wrapper">
        <h2>Output</h2>
        <canvas id="outputCanvas"></canvas>
      </div>
    </div>
  </div>

  <div class="footer">
    <span>Select a mode, tweak parameters, and click "Apply".</span>
    <span>Version: <span class="js-version-footer"></span></span>
  </div>

  <script>
    window.onload = function () {
      const APP_VERSION = '0.11.0';
      const STORAGE_KEY = 'pixelShuffler_lastImageDataUrl_v1';

      const vInline = document.querySelector('.js-version-inline');
      const vFooter = document.querySelector('.js-version-footer');
      if (vInline) vInline.textContent = `· v${APP_VERSION}`;
      if (vFooter) vFooter.textContent = APP_VERSION;

      const fileInput      = document.getElementById('fileInput');
      const modeSelect     = document.getElementById('modeSelect');
      const moundsLabel    = document.getElementById('moundsLabel');
      const moundsSelect   = document.getElementById('moundsSelect');
      const shiftLabel     = document.getElementById('shiftLabel');
      const shiftSizeInput = document.getElementById('shiftSizeInput');
      const applyBtn       = document.getElementById('applyBtn');
      const downloadBtn    = document.getElementById('downloadBtn');
      const statusText     = document.getElementById('statusText');

      const originalCanvas = document.getElementById('originalCanvas');
      const outputCanvas   = document.getElementById('outputCanvas');
      const originalCtx    = originalCanvas.getContext('2d');
      const outputCtx      = outputCanvas.getContext('2d');

      let imageLoaded = false;
      let lastImageData = null;

      function setStatus(msg) {
        statusText.textContent = msg || '';
      }

      // RGB -> HSV helper
      function rgbToHsv(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d   = max - min;

        let h = 0;
        const v = max;
        const s = max === 0 ? 0 : d / max;

        if (d !== 0) {
          if (max === r) {
            h = ((g - b) / d) % 6;
          } else if (max === g) {
            h = (b - r) / d + 2;
          } else {
            h = (r - g) / d + 4;
          }
          h *= 60;
          if (h < 0) h += 360;
        }

        return { h, s, v };
      }

      // Mound profile for Sand Layout
      function generateMoundProfile(width, moundCount) {
        const m = Math.max(1, Math.min(6, moundCount));
        const centers = [];
        const amplitudes = [];
        const sigmas = [];

        for (let i = 0; i < m; i++) {
          const centerX = (i + 0.5) * (width / m);
          centers.push(centerX);
        }

        for (let i = 0; i < m; i++) {
          const amp = 0.6 + Math.random() * 0.3;
          amplitudes.push(amp);
          const sigma = width / (m * 2.5);
          sigmas.push(sigma);
        }

        const profile = new Float32Array(width);

        for (let x = 0; x < width; x++) {
          let hNorm = 0;
          for (let i = 0; i < m; i++) {
            const dx = x - centers[i];
            const s = sigmas[i];
            const gauss = amplitudes[i] * Math.exp(-0.5 * (dx * dx) / (s * s));
            if (gauss > hNorm) hNorm = gauss;
          }
          if (hNorm > 1) hNorm = 1;
          profile[x] = hNorm;
        }

        return profile;
      }

      // Sand Layout transform
      function transformToSandLayout(imageData, moundCount) {
        const { data, width, height } = imageData;
        const numPixels = width * height;

        const pixels = new Array(numPixels);
        for (let i = 0; i < numPixels; i++) {
          const offset = i * 4;
          const r = data[offset];
          const g = data[offset + 1];
          const b = data[offset + 2];
          const a = data[offset + 3];

          const { v } = rgbToHsv(r, g, b);
          pixels[i] = { r, g, b, a, v };
        }

        pixels.sort((p1, p2) => p1.v - p2.v);

        const profile = generateMoundProfile(width, moundCount);

        const coords = new Array(numPixels);
        const insideWeight = 0.88;

        for (let y = 0; y < height; y++) {
          const yFromBottom = (height - 1) - y;
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const hNorm = profile[x];
            const moundHeight = hNorm * (height - 1);
            let t;

            if (moundHeight > 1 && yFromBottom <= moundHeight) {
              const tInside = moundHeight <= 0 ? 0 : (yFromBottom / moundHeight);
              t = tInside * insideWeight;
            } else {
              const remainingHeight = (height - 1) - moundHeight;
              if (remainingHeight <= 0) {
                t = insideWeight;
              } else {
                const yAbove = yFromBottom - moundHeight;
                const tOutside = Math.max(0, Math.min(1, yAbove / remainingHeight));
                t = insideWeight + tOutside * (1 - insideWeight);
              }
            }

            coords[idx] = { x, y, t };
          }
        }

        coords.sort((c1, c2) => c1.t - c2.t);

        const outData = new Uint8ClampedArray(data.length);

        for (let i = 0; i < numPixels; i++) {
          const { x, y } = coords[i];
          const p = pixels[i];
          const offset = (y * width + x) * 4;

          outData[offset]     = p.r;
          outData[offset + 1] = p.g;
          outData[offset + 2] = p.b;
          outData[offset + 3] = p.a;
        }

        return new ImageData(outData, width, height);
      }

      // Vertical Shift transform
      function transformVerticalShift(imageData, shiftSize) {
        const { data, width, height } = imageData;
        const outData = new Uint8ClampedArray(data.length);

        const step = Math.max(1, Math.floor(shiftSize));
        const effectiveShift = step % height;

        for (let x = 0; x < width; x++) {
          const blockIndex = Math.floor(x / step);
          const direction = (blockIndex % 2 === 0) ? -effectiveShift : effectiveShift;

          for (let y = 0; y < height; y++) {
            const srcY = (y - direction + height) % height;
            const srcOffset = (srcY * width + x) * 4;
            const dstOffset = (y * width + x) * 4;

            outData[dstOffset]     = data[srcOffset];
            outData[dstOffset + 1] = data[srcOffset + 1];
            outData[dstOffset + 2] = data[srcOffset + 2];
            outData[dstOffset + 3] = data[srcOffset + 3];
          }
        }

        return new ImageData(outData, width, height);
      }

      // Horizontal Shift transform
      function transformHorizontalShift(imageData, shiftSize) {
        const { data, width, height } = imageData;
        const outData = new Uint8ClampedArray(data.length);

        const step = Math.max(1, Math.floor(shiftSize));
        const effectiveShift = step % width;

        for (let y = 0; y < height; y++) {
          const blockIndex = Math.floor(y / step);
          const direction = (blockIndex % 2 === 0) ? -effectiveShift : effectiveShift;

          for (let x = 0; x < width; x++) {
            const srcX = (x - direction + width) % width;
            const srcOffset = (y * width + srcX) * 4;
            const dstOffset = (y * width + x) * 4;

            outData[dstOffset]     = data[srcOffset];
            outData[dstOffset + 1] = data[srcOffset + 1];
            outData[dstOffset + 2] = data[srcOffset + 2];
            outData[dstOffset + 3] = data[srcOffset + 3];
          }
        }

        return new ImageData(outData, width, height);
      }

      // Mode UI toggle
      modeSelect.addEventListener('change', () => {
        const mode = modeSelect.value;
        if (mode === 'sand') {
          moundsLabel.style.display = '';
          shiftLabel.style.display = 'none';
          setStatus('Sand Layout mode: pixels reordered into mound-shaped layers.');
        } else {
          moundsLabel.style.display = 'none';
          shiftLabel.style.display = '';
          if (mode === 'verticalShift') {
            setStatus('Vertical Shift mode: column blocks shift up/down.');
          } else {
            setStatus('Horizontal Shift mode: row blocks shift left/right.');
          }
        }
      });

      // Draw image (shared for load + restore)
      function drawImageFromSrc(src) {
        const img = new Image();
        img.onload = () => {
          const maxSide = 800;
          let { width, height } = img;

          if (width > maxSide || height > maxSide) {
            const scale = Math.min(maxSide / width, maxSide / height);
            width = Math.round(width * scale);
            height = Math.round(height * scale);
          }

          originalCanvas.width  = width;
          originalCanvas.height = height;
          outputCanvas.width    = width;
          outputCanvas.height   = height;

          originalCtx.clearRect(0, 0, width, height);
          outputCtx.clearRect(0, 0, width, height);

          originalCtx.drawImage(img, 0, 0, width, height);
          lastImageData = originalCtx.getImageData(0, 0, width, height);

          imageLoaded = true;
          downloadBtn.disabled = true;
          setStatus('Image ready. Choose mode and parameters, then click "Apply".');
        };
        img.src = src;
      }

      // Restore last image from localStorage (if available)
      const savedUrl = localStorage.getItem(STORAGE_KEY);
      if (savedUrl) {
        try {
          drawImageFromSrc(savedUrl);
          setStatus('Restored last image from previous session.');
        } catch (e) {
          console.warn('Could not restore saved image:', e);
          setStatus('Load an image to get started.');
        }
      } else {
        setStatus('Load an image to get started.');
      }

      // Image loading from file input
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = (e) => {
          const dataUrl = e.target.result;
          try {
            localStorage.setItem(STORAGE_KEY, dataUrl);
          } catch (err) {
            console.warn('Could not store image in localStorage (maybe too large):', err);
          }
          drawImageFromSrc(dataUrl);
        };

        reader.onerror = () => {
          setStatus('Error loading image. Please try another file.');
        };

        reader.readAsDataURL(file);
        setStatus('Reading image...');
      });

      // Apply button
      applyBtn.addEventListener('click', () => {
        if (!imageLoaded || !lastImageData) {
          alert('Please load an image first.');
          return;
        }

        const mode = modeSelect.value;
        setStatus('Processing...');

        setTimeout(() => {
          try {
            let result;
            if (mode === 'sand') {
              const moundCount = parseInt(moundsSelect.value, 10) || 2;
              result = transformToSandLayout(lastImageData, moundCount);
            } else if (mode === 'verticalShift') {
              const shiftSize = parseInt(shiftSizeInput.value, 10) || 1;
              result = transformVerticalShift(lastImageData, shiftSize);
            } else {
              const shiftSize = parseInt(shiftSizeInput.value, 10) || 1;
              result = transformHorizontalShift(lastImageData, shiftSize);
            }

            outputCtx.putImageData(result, 0, 0);
            downloadBtn.disabled = false;
            setStatus('Done. You can download the result.');
          } catch (err) {
            console.error(err);
            setStatus('Error during processing.');
          }
        }, 30);
      });

      // Download button
      downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'pixel-shuffler-output.png';
        link.href = outputCanvas.toDataURL('image/png');
        link.click();
      });
    };
  </script>
</body>
</html>
