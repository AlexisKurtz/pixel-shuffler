<!--
Pixel Shuffler - Sand Layers + Combined Grid Shift
Version: 0.12.0

Changelog:
- 0.12.0
  - Replaced separate Vertical/Horizontal modes with a single "Grid Shift" mode
    that combines both vertical and horizontal block-based displacements:
      * Vertical: columns are grouped in blocks of size V pixels (user-defined).
        For each block:
          - First block: shift its columns UP by V pixels (wrap).
          - Next block: shift its columns DOWN by V pixels.
          - Alternating across the width.
      * Horizontal: rows are grouped in blocks of size H pixels (user-defined).
        For each block:
          - First block: shift its rows LEFT by H pixels (wrap).
          - Next block: shift its rows RIGHT by H pixels.
          - Alternating down the height.
      * Both axes are applied in one mode: Grid Shift.
      * Pure pixel rearrangement: no pixels created or removed.
  - Added two separate selectors: Vertical shift (px) and Horizontal shift (px),
    plus a chain toggle to link/unlink their values:
      * When linked, changing one updates the other.
      * When unlinked, they can be set independently.
- 0.11.0
  - Added persistence of last loaded image with localStorage.
- 0.10.x / 0.9.x
  - Sand Layout mode: brightness-based mound layout with true pixel shuffling.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Pixel Shuffler MVP</title>
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #111;
      color: #f5f5f5;
      margin: 0;
      padding: 20px;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 20px;
    }

    h1 {
      margin: 0;
      font-size: 1.6rem;
      display: flex;
      align-items: baseline;
      gap: 8px;
    }

    .version-inline {
      font-size: 0.85rem;
      opacity: 0.7;
    }

    .app {
      max-width: 1000px;
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      background: #1b1b1b;
      padding: 10px 12px;
      border-radius: 8px;
    }

    .controls label {
      font-size: 0.9rem;
      opacity: 0.9;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    input[type="file"] {
      font-size: 0.9rem;
    }

    select, button, input[type="number"] {
      background: #222;
      color: #f5f5f5;
      border: 1px solid #444;
      border-radius: 6px;
      padding: 6px 10px;
      font-size: 0.9rem;
      cursor: pointer;
    }

    button:hover {
      background: #333;
    }

    input[type="number"] {
      width: 70px;
    }

    #linkShiftsBtn {
      padding: 6px 10px;
      font-size: 0.85rem;
    }

    .canvases {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
      gap: 16px;
      align-items: flex-start;
    }

    .canvas-wrapper {
      background: #1b1b1b;
      border-radius: 8px;
      padding: 10px;
    }

    .canvas-wrapper h2 {
      font-size: 0.95rem;
      margin: 0 0 8px 0;
      opacity: 0.85;
    }

    canvas {
      max-width: 100%;
      border-radius: 4px;
      background: #000;
      display: block;
    }

    .status {
      font-size: 0.9rem;
      opacity: 0.8;
      min-height: 1.2em;
    }

    .footer {
      font-size: 0.8rem;
      opacity: 0.7;
      margin-top: 10px;
      display: flex;
      gap: 8px;
      align-items: baseline;
      justify-content: space-between;
      width: 100%;
      max-width: 1000px;
    }
  </style>
</head>
<body>
  <div class="app">
    <h1>
      Pixel Shuffler
      <span class="version-inline js-version-inline"></span>
    </h1>

    <div class="controls">
      <label>
        Image:
        <input type="file" id="fileInput" accept="image/*" />
      </label>

      <label>
        Mode:
        <select id="modeSelect">
          <option value="sand">Sand Layout</option>
          <option value="gridShift">Grid Shift</option>
        </select>
      </label>

      <label id="moundsLabel">
        Mounds:
        <select id="moundsSelect">
          <option value="1">1</option>
          <option value="2" selected>2</option>
          <option value="3">3</option>
          <option value="4">4</option>
          <option value="5">5</option>
          <option value="6">6</option>
        </select>
      </label>

      <label id="vShiftLabel" style="display:none;">
        Vertical shift (px):
        <input type="number" id="vShiftInput" min="0" max="500" value="20" />
      </label>

      <label id="hShiftLabel" style="display:none;">
        Horizontal shift (px):
        <input type="number" id="hShiftInput" min="0" max="500" value="20" />
      </label>

      <button id="linkShiftsBtn" type="button" style="display:none;" aria-pressed="true" title="Link/unlink vertical and horizontal shift values">
        ðŸ”— Linked
      </button>

      <button id="applyBtn">Apply</button>
      <button id="downloadBtn" disabled>Download Result</button>

      <span class="status" id="statusText"></span>
    </div>

    <div class="canvases">
      <div class="canvas-wrapper">
        <h2>Original</h2>
        <canvas id="originalCanvas"></canvas>
      </div>
      <div class="canvas-wrapper">
        <h2>Output</h2>
        <canvas id="outputCanvas"></canvas>
      </div>
    </div>
  </div>

  <div class="footer">
    <span>Select a mode, tweak parameters, and click "Apply".</span>
    <span>Version: <span class="js-version-footer"></span></span>
  </div>

  <script>
    window.onload = function () {
      const APP_VERSION = '0.12.0';
      const STORAGE_KEY = 'pixelShuffler_lastImageDataUrl_v1';

      const vInline = document.querySelector('.js-version-inline');
      const vFooter = document.querySelector('.js-version-footer');
      if (vInline) vInline.textContent = `Â· v${APP_VERSION}`;
      if (vFooter) vFooter.textContent = APP_VERSION;

      const fileInput      = document.getElementById('fileInput');
      const modeSelect     = document.getElementById('modeSelect');
      const moundsLabel    = document.getElementById('moundsLabel');
      const moundsSelect   = document.getElementById('moundsSelect');
      const vShiftLabel    = document.getElementById('vShiftLabel');
      const hShiftLabel    = document.getElementById('hShiftLabel');
      const vShiftInput    = document.getElementById('vShiftInput');
      const hShiftInput    = document.getElementById('hShiftInput');
      const linkShiftsBtn  = document.getElementById('linkShiftsBtn');
      const applyBtn       = document.getElementById('applyBtn');
      const downloadBtn    = document.getElementById('downloadBtn');
      const statusText     = document.getElementById('statusText');

      const originalCanvas = document.getElementById('originalCanvas');
      const outputCanvas   = document.getElementById('outputCanvas');
      const originalCtx    = originalCanvas.getContext('2d');
      const outputCtx      = outputCanvas.getContext('2d');

      let imageLoaded = false;
      let lastImageData = null;
      let linkShifts = true;

      function setStatus(msg) {
        statusText.textContent = msg || '';
      }

      function updateLinkButton() {
        linkShiftsBtn.setAttribute('aria-pressed', linkShifts ? 'true' : 'false');
        linkShiftsBtn.textContent = linkShifts ? 'ðŸ”— Linked' : 'â›“ Unlinked';
      }

      // RGB -> HSV helper
      function rgbToHsv(r, g, b) {
        r /= 255;
        g /= 255;
        b /= 255;

        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        const d   = max - min;

        let h = 0;
        const v = max;
        const s = max === 0 ? 0 : d / max;

        if (d !== 0) {
          if (max === r) {
            h = ((g - b) / d) % 6;
          } else if (max === g) {
            h = (b - r) / d + 2;
          } else {
            h = (r - g) / d + 4;
          }
          h *= 60;
          if (h < 0) h += 360;
        }

        return { h, s, v };
      }

      // Mound profile for Sand Layout
      function generateMoundProfile(width, moundCount) {
        const m = Math.max(1, Math.min(6, moundCount));
        const centers = [];
        const amplitudes = [];
        const sigmas = [];

        for (let i = 0; i < m; i++) {
          const centerX = (i + 0.5) * (width / m);
          centers.push(centerX);
        }

        for (let i = 0; i < m; i++) {
          const amp = 0.6 + Math.random() * 0.3;
          amplitudes.push(amp);
          const sigma = width / (m * 2.5);
          sigmas.push(sigma);
        }

        const profile = new Float32Array(width);

        for (let x = 0; x < width; x++) {
          let hNorm = 0;
          for (let i = 0; i < m; i++) {
            const dx = x - centers[i];
            const s = sigmas[i];
            const gauss = amplitudes[i] * Math.exp(-0.5 * (dx * dx) / (s * s));
            if (gauss > hNorm) hNorm = gauss;
          }
          if (hNorm > 1) hNorm = 1;
          profile[x] = hNorm;
        }

        return profile;
      }

      // Sand Layout transform
      function transformToSandLayout(imageData, moundCount) {
        const { data, width, height } = imageData;
        const numPixels = width * height;

        const pixels = new Array(numPixels);
        for (let i = 0; i < numPixels; i++) {
          const offset = i * 4;
          const r = data[offset];
          const g = data[offset + 1];
          const b = data[offset + 2];
          const a = data[offset + 3];

          const { v } = rgbToHsv(r, g, b);
          pixels[i] = { r, g, b, a, v };
        }

        // brightness-only sort: dark -> light
        pixels.sort((p1, p2) => p1.v - p2.v);

        const profile = generateMoundProfile(width, moundCount);

        const coords = new Array(numPixels);
        const insideWeight = 0.88;

        for (let y = 0; y < height; y++) {
          const yFromBottom = (height - 1) - y;
          for (let x = 0; x < width; x++) {
            const idx = y * width + x;
            const hNorm = profile[x];
            const moundHeight = hNorm * (height - 1);
            let t;

            if (moundHeight > 1 && yFromBottom <= moundHeight) {
              const tInside = moundHeight <= 0 ? 0 : (yFromBottom / moundHeight);
              t = tInside * insideWeight;
            } else {
              const remainingHeight = (height - 1) - moundHeight;
              if (remainingHeight <= 0) {
                t = insideWeight;
              } else {
                const yAbove = yFromBottom - moundHeight;
                const tOutside = Math.max(0, Math.min(1, yAbove / remainingHeight));
                t = insideWeight + tOutside * (1 - insideWeight);
              }
            }

            coords[idx] = { x, y, t };
          }
        }

        coords.sort((c1, c2) => c1.t - c2.t);

        const outData = new Uint8ClampedArray(data.length);

        for (let i = 0; i < numPixels; i++) {
          const { x, y } = coords[i];
          const p = pixels[i];
          const offset = (y * width + x) * 4;

          outData[offset]     = p.r;
          outData[offset + 1] = p.g;
          outData[offset + 2] = p.b;
          outData[offset + 3] = p.a;
        }

        return new ImageData(outData, width, height);
      }

      // Combined Grid Shift transform (vertical + horizontal)
      function transformGridShift(imageData, vShiftSize, hShiftSize) {
        const { width, height } = imageData;
        let currentData = imageData.data;
        let working = currentData;

        // Vertical component (columns in horizontal blocks)
        const vStep = Math.max(0, Math.floor(vShiftSize));
        if (vStep > 0) {
          const effectiveVShift = vStep % height;
          const vOut = new Uint8ClampedArray(currentData.length);

          for (let x = 0; x < width; x++) {
            const blockIndex = Math.floor(x / vStep);
            const direction = (blockIndex % 2 === 0) ? -effectiveVShift : effectiveVShift;

            for (let y = 0; y < height; y++) {
              const srcY = (y - direction + height) % height;
              const srcOffset = (srcY * width + x) * 4;
              const dstOffset = (y * width + x) * 4;

              vOut[dstOffset]     = working[srcOffset];
              vOut[dstOffset + 1] = working[srcOffset + 1];
              vOut[dstOffset + 2] = working[srcOffset + 2];
              vOut[dstOffset + 3] = working[srcOffset + 3];
            }
          }

          working = vOut;
        }

        // Horizontal component (rows in vertical blocks)
        const hStep = Math.max(0, Math.floor(hShiftSize));
        if (hStep > 0) {
          const effectiveHShift = hStep % width;
          const hOut = new Uint8ClampedArray(working.length);

          for (let y = 0; y < height; y++) {
            const blockIndex = Math.floor(y / hStep);
            const direction = (blockIndex % 2 === 0) ? -effectiveHShift : effectiveHShift;

            for (let x = 0; x < width; x++) {
              const srcX = (x - direction + width) % width;
              const srcOffset = (y * width + srcX) * 4;
              const dstOffset = (y * width + x) * 4;

              hOut[dstOffset]     = working[srcOffset];
              hOut[dstOffset + 1] = working[srcOffset + 1];
              hOut[dstOffset + 2] = working[srcOffset + 2];
              hOut[dstOffset + 3] = working[srcOffset + 3];
            }
          }

          working = hOut;
        }

        return new ImageData(working, width, height);
      }

      // Mode UI toggle
      modeSelect.addEventListener('change', () => {
        const mode = modeSelect.value;
        if (mode === 'sand') {
          moundsLabel.style.display   = '';
          vShiftLabel.style.display   = 'none';
          hShiftLabel.style.display   = 'none';
          linkShiftsBtn.style.display = 'none';
          setStatus('Sand Layout mode: pixels reordered into mound-shaped layers.');
        } else {
          moundsLabel.style.display   = 'none';
          vShiftLabel.style.display   = '';
          hShiftLabel.style.display   = '';
          linkShiftsBtn.style.display = '';
          setStatus('Grid Shift mode: combined vertical and horizontal block displacements.');
        }
      });

      // Link/unlink shift values
      linkShiftsBtn.addEventListener('click', () => {
        linkShifts = !linkShifts;
        if (linkShifts) {
          // When re-linking, sync horizontal to vertical by default
          hShiftInput.value = vShiftInput.value;
        }
        updateLinkButton();
      });

      vShiftInput.addEventListener('input', () => {
        if (linkShifts) {
          hShiftInput.value = vShiftInput.value;
        }
      });

      hShiftInput.addEventListener('input', () => {
        if (linkShifts) {
          vShiftInput.value = hShiftInput.value;
        }
      });

      updateLinkButton();

      // Draw image from a data URL (used for file + restore)
      function drawImageFromSrc(src) {
        const img = new Image();
        img.onload = () => {
          const maxSide = 800;
          let { width, height } = img;

          if (width > maxSide || height > maxSide) {
            const scale = Math.min(maxSide / width, maxSide / height);
            width = Math.round(width * scale);
            height = Math.round(height * scale);
          }

          originalCanvas.width  = width;
          originalCanvas.height = height;
          outputCanvas.width    = width;
          outputCanvas.height   = height;

          originalCtx.clearRect(0, 0, width, height);
          outputCtx.clearRect(0, 0, width, height);

          originalCtx.drawImage(img, 0, 0, width, height);
          lastImageData = originalCtx.getImageData(0, 0, width, height);

          imageLoaded = true;
          downloadBtn.disabled = true;
          setStatus('Image ready. Choose mode and parameters, then click "Apply".');
        };
        img.src = src;
      }

      // Restore last image from localStorage
      const savedUrl = localStorage.getItem(STORAGE_KEY);
      if (savedUrl) {
        try {
          drawImageFromSrc(savedUrl);
          setStatus('Restored last image from previous session.');
        } catch (e) {
          console.warn('Could not restore saved image:', e);
          setStatus('Load an image to get started.');
        }
      } else {
        setStatus('Load an image to get started.');
      }

      // Image loading from file input
      fileInput.addEventListener('change', (event) => {
        const file = event.target.files[0];
        if (!file) return;

        const reader = new FileReader();

        reader.onload = (e) => {
          const dataUrl = e.target.result;
          try {
            localStorage.setItem(STORAGE_KEY, dataUrl);
          } catch (err) {
            console.warn('Could not store image in localStorage (maybe too large):', err);
          }
          drawImageFromSrc(dataUrl);
        };

        reader.onerror = () => {
          setStatus('Error loading image. Please try another file.');
        };

        reader.readAsDataURL(file);
        setStatus('Reading image...');
      });

      // Apply button
      applyBtn.addEventListener('click', () => {
        if (!imageLoaded || !lastImageData) {
          alert('Please load an image first.');
          return;
        }

        const mode = modeSelect.value;
        setStatus('Processing...');

        setTimeout(() => {
          try {
            let result;
            if (mode === 'sand') {
              const moundCount = parseInt(moundsSelect.value, 10) || 2;
              result = transformToSandLayout(lastImageData, moundCount);
            } else {
              const vShift = Math.max(0, parseInt(vShiftInput.value, 10) || 0);
              const hShift = Math.max(0, parseInt(hShiftInput.value, 10) || 0);
              result = transformGridShift(lastImageData, vShift, hShift);
            }

            outputCtx.putImageData(result, 0, 0);
            downloadBtn.disabled = false;
            setStatus('Done. You can download the result.');
          } catch (err) {
            console.error(err);
            setStatus('Error during processing.');
          }
        }, 30);
      });

      // Download button
      downloadBtn.addEventListener('click', () => {
        const link = document.createElement('a');
        link.download = 'pixel-shuffler-output.png';
        link.href = outputCanvas.toDataURL('image/png');
        link.click();
      });
    };
  </script>
</body>
</html>
